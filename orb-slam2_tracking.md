# tracking线程

tracking 线程为主线程

由System::TrackMonocular调用GrabImageMonocular而进入开始tracking。如果系统还没有初始化(mState==NOT_INITIALIZED)则进入1进行初始化，否则进入2。

## 1. 初始化

如果系统还没有初始化(mState==NOT_INITIALIZED)，则最开始的步骤就是进行单目初始化MonocularInitialization()，需要满足相邻的两帧提取的特征点都大于100个。

1、MonocularInitialization

第一次进入该方法（未创建初始化器），如果当前帧关键点数>100，创建一个初始化器；第二次进入该方法的时候，已经有初始化器了，如果当前帧中的关键点数>100，则进行匹配，进入1.1，否则，删除初始化器。

1.1、SearchForInitialization

利用ORB匹配器，在当前帧中搜索初始帧中提取的特征点进行匹配。遍历参考帧F1中的所有特征点，在帧2中以当前遍历特帧点为中心的半径窗口内搜索候选匹配特征点（GetFeaturesInArea）。遍历搜索窗口中的所有匹配候选点，计算F1当前遍历特帧点与F2所有匹配候选点两两描述子的距离，找到最小的和次小的特征点。对最优次优结果进行检查，需要满足阈值。且最佳距离/次佳距离之比要小于设定的比例，这样特征点辨识度更高。将最后通过筛选的匹配好的特征点保存到vbPrevMatched并返回。

匹配关键点数小于100时失败，删除初始化器。如果大于100，计算单应矩阵和基础矩阵，进入1.2。

1.2、Initialize

利用初始化器根据当前帧及前一帧到当前帧的匹配关键点信息进行单应矩阵和基础矩阵的计算，进而计算出相机位姿的旋转矩阵和平移矩阵。首先重新记录特征点对的匹配关系存储在mvMatches12，是否有匹配存储在mvbMatched1，即把vMatches12（有冗余）转化为 mvMatches12。在所有匹配特征点对中随机选择8对匹配特征点为一组，用于估计H矩阵和F矩阵，共选择 mMaxIterations (默认200) 组。开始RANSAC迭代，迭代mMaxIterations次，选取每次迭代时使用的特征点索引放在mvSets。构造两个线程分别计算H矩阵和F矩阵。

FindHomography：RANSAC迭代，八点法计算单应矩阵

```
/** 
 * 基本原理：见附件推导过程：
 * |x'|     | h1 h2 h3 ||x|
 * |y'| = a | h4 h5 h6 ||y|  简写: x' = a H x, a为一个尺度因子
 * |1 |     | h7 h8 h9 ||1|
 * 使用DLT(direct linear tranform)求解该模型
 * x' = a H x 
 * ---> (x') 叉乘 (H x)  = 0  (因为方向相同) (取前两行就可以推导出下面的了)
 * ---> Ah = 0 
 * A = | 0  0  0 -x -y -1 xy' yy' y'|  h = | h1 h2 h3 h4 h5 h6 h7 h8 h9 |
 *     |-x -y -1  0  0  0 xx' yx' x'|
 * A 矩阵大小为16*9
 * 通过SVD求解Ah = 0，A^T*A最小特征值对应的特征向量即为解
 * 其实也就是右奇异值矩阵的最后一列，即最小特征值对应的特征向量就是单应矩阵
*/
```

FindFundamental： 也是8点法，计算基础矩阵

```
/**
 * 计算基础矩阵
 * 本质矩阵为E,vP2的坐标为(u2,v2,1),vP1的坐标为(u1,v1,1)
 * 公式vP2*E*vP1=0成立，展开来就是下面公式：
 *               |e1 e2 e3|  |u1|
 * (u2, v1, 1) * |e4 e5 e6| *|v1| = 0
 *               |e7 e8 e9|  |1 |
 * 计算整理可得：
 * u2*u1*e1 + u2*v1*e2 + u2*e3 + v2*u1*e4 + v2*v1*e5 + v2*e6 + u1*e7 + v1*e8 + 1*e9 = 0
 * 将E作为向量提取出来可得：
 * (u2*u1 + u2*v1 + u2 + v2*u1 + v2*v1 + v2 + u1 + v1 + 1) * E = 0
 * 这个函数中构造的A矩阵就是根据这个来构造的，大小为8*9
 * 进行SVD分解，可以求出本质矩阵E,进而根据公式F=K^-T*E*K^-1来计算出F
 * 
*/
```

根据单应矩阵得分和基础矩阵得分选择哪一个来恢复运动，即计算出R和t，成功则返回true。

如果成功求得H矩阵和F矩阵，则继续。删除那些无法进行三角化的匹配点。将初始化的第一帧作为世界坐标系，因此第一帧变换矩阵为单位矩阵。由旋转矩阵和平移矩阵构造变换矩阵。

CreateInitialMapMonocular将3D点包装成MapPoint类型存入KeyFrame和Map中。



## 2. 跟踪

如果已经初始化过，则开始跟踪。

判断模式，mbOnlyTracking等于false表示正常SLAM模式（定位+地图更新），mbOnlyTracking等于true表示仅定位模式，只进行跟踪。mbOnlyTracking为false则进入1，否则进入2。

1、正常SLAM模式，mbOnlyTracking==false，定位+地图更新

判断是否正常跟踪，mState==OK是否成立，是则进入1.1，否则进入1.2

1.1、跟踪正常，mState==OK

判断运动模型是空的或刚完成重定位，是则跟踪参考关键帧进入1.1.1，如果运动模型为空,说明是刚初始化开始，或者已经跟丢了；如果当前帧紧紧地跟着在重定位的帧的后面，我们将重定位帧来恢复位姿。否则恒速模型跟踪进入1.1.2。

1.1.1、TrackReferenceKeyFrame

用最近的关键帧来跟踪当前的普通帧。首先将当前帧的描述子转化为BoW向量。通过词袋BoW加速当前帧与参考帧之间的特征点匹配，如果匹配数目小于15则跟踪失败，否则继续。将上一帧的位姿态作为当前帧位姿的初始值。通过优化3D-2D的重投影误差来获得位姿，通过位姿优化函数PoseOptimization来完成，后面会专门讲解优化。剔除优化后的匹配点中的外点。跟踪成功的数目超过10才认为跟踪成功返回true，否则跟踪失败。

1.1.2、TrackWithMotionModel

根据匀速度模型对上一帧的MapPoints进行跟踪。首先根据Const Velocity Model(认为这两帧之间的相对运动和之前两帧间相对运动相同)估计当前帧的位姿。根据匀速度模型进行对上一帧的MapPoints进行跟踪匹配，进入1.1.2.1SearchByProjection

1.1.2.1、SearchByProjection

将上一帧跟踪的地图点投影到当前帧，并且搜索匹配点，用于跟踪前一帧。建立旋转直方图，用于检测旋转一致性。计算当前帧和前一帧的平移向量。对于前一帧的每一个地图点，通过相机投影模型，得到投影到当前帧的像素坐标。根据相机的前后前进方向来判断搜索尺度范围，记录候选的匹配点。遍历候选匹配点，通过前一帧遍历的当前地图点和每一个候选匹配点计算描述子距离，寻找距离最小的最佳匹配点 。最佳匹配距离要小于设定阈值，计算匹配点旋转角度差所在的直方图，进行旋转一致检测，剔除不一致的匹配。返回满足条件的匹配数目nmatches。

如果返回的匹配数目nmatches小于20，则扩大搜索半径再来一次SearchByProjection，如果返回的匹配数目nmatches仍小于20，则跟踪失败，否则继续。进入位姿势优化PoseOptimization。优化位姿后剔除mvpMapPoints的outlier。经过优化后，如果是仅跟踪模式（mbOnlyTracking==true），未优化匹配数目nmatches>20则返回true，如果是正常模式，优化匹配数目nmatchesMap>=10返回true，否则返回false。

根据TrackWithMotionModel返回值，如果恒速模型失败了（bOK==false），则只能根据参考关键帧来跟踪再次进入TrackReferenceKeyFrame。

1.2、mState!=OK

如果跟踪状态不成功,那么就只能重定位了，进入1.2.1

1.2.1、Relocalization

计算当前帧特征点的词袋向量。用词袋从关键帧数据库找到与当前帧相似的候选关键帧。遍历所有的候选关键帧，当前帧和候选关键帧用BoW进行快速匹配，如果和当前帧的匹配数小于15，则继续下一帧，如果大于等于15，则用当前帧及当前帧与候选帧的地图点匹配关系初始化PnPsolver。编译每一个PnPsolver，迭代5次利用EPnP算法估计姿态。如果EPnP 计算出了位姿，对内点进行BA优化，进入位姿优化PoseOptimization。如果优化之后的内点数目小于10，跳过了当前候选关键帧，继续下一候选帧。如果内点数小于50，则进入SearchByProjection通过投影的方式将候选关键帧中未匹配的地图点投影到当前帧中, 生成新的匹配，对之前未匹配的点进行匹配，再进行优化求解。如果新增匹配+原有匹配大于等于50，再次优化位姿PoseOptimization，如果BA后内点数还是比较少(<50)&&(>30)，使用更小的窗口重新进行投影搜索匹配，新增匹配+原有匹配大于等于50，则最后BA优化一下。如果内点数大于等于50，bMatch=true。如果bMatch==false，返回false。如果bMatch==true，那么就直接认为重定位成功，记录成功重定位帧的id，返回true。



2、仅定位模式，只进行跟踪，局部地图不工作，mbOnlyTracking==true

判断mState，mState==LOST则进入2.1，否则进入2.2

2.1、mState==LOST

如果跟丢了，只能重定位，进入Relocalization

2.2、mState!=LOST

判断mbVO情况，此帧是否匹配了足够的MapPoints。

如果跟踪正常mbVO==false，使用恒速模型 或 参考关键帧跟踪。

如果mbVO==true，表明此帧匹配了很少（小于10）的地图点，既做跟踪又做重定位。当运动模型有效的时候，先根据运动模型计算位姿。使用重定位的方法来得到当前帧的位姿。根据前面的恒速模型、重定位结果来更新状态。



3、跟踪局部地图

在跟踪得到当前帧初始姿态后，现在对local map进行跟踪得到更多的匹配，并优化当前位姿。

前面只是跟踪一帧得到初始位姿，这里搜索局部关键帧、局部地图点，和当前帧进行投影匹配，得到更多匹配的MapPoints后进行Pose优化。

进入3.1

3.1、TrackLocalMap

3.1.1、更新局部地图UpdateLocalMap

更新局部关键帧 mvpLocalKeyFrames 和局部地图点 mvpLocalMapPoints

1）更新局部关键帧UpdateLocalKeyFrames

遍历当前帧的地图点，记录所有能观测到当前帧地图点的关键帧及共视程度。更新局部关键帧（mvpLocalKeyFrames），添加局部关键帧的3种类型：类型1：能观测到当前帧地图点的关键帧作为局部关键帧 （将邻居拉拢入伙）（一级共视关键帧） ；类型2:一级共视关键帧的共视（前10个）关键帧，称为二级共视关键帧（将邻居的邻居拉拢入伙）；类型3:将一级共视关键帧的父子关键帧作为局部关键帧（将邻居的父子拉拢入伙）。更新当前帧的参考关键帧，与自己共视程度最高的关键帧作为参考关键帧。

2）更新局部关键点UpdateLocalPoints

遍历局部关键帧 mvpLocalKeyFrames，将局部关键帧的地图点添加到mvpLocalMapPoints。

3.1.2、搜索局部地图点SearchLocalPoints

用局部地图点进行投影匹配，得到更多的匹配关系。

遍历当前帧的地图点，标记这些地图点不参与之后的投影搜索匹配，局部地图点中当前帧地图点不需要再投影，只需要将此外的局部地图点在当前帧进行投影匹配。判断所有局部地图点中除当前帧地图点外的点，是否在当前帧视野范围内。如果在当前帧视野范围需要进行投影匹配的点的数目大于0，就进行投影匹配，增加更多的匹配关系。通过SearchByProjection投影匹配得到更多的匹配关系。

3.1.3、前面新增了更多的匹配关系，通过BA优化得到更准确的位姿。

3.1.4、更新当前帧的地图点被观测程度，并统计跟踪局部地图后匹配数目。根据跟踪匹配数目及重定位情况决定是否跟踪成功。如果最近刚刚发生了重定位,那么成功匹配数小于50个点则跟踪失败。如果是正常的状态话只要跟踪的地图点大于30个就认为成功了。



4、更新显示线程中的图像、特征点、地图点等信息mpFrameDrawer->Update(this)：

将跟踪线程的数据拷贝到绘图线程（图像、特征点、地图、跟踪状态）



5、跟踪成功，更新恒速运动模型

更新显示中的位姿

清理当前帧的地图点中没有被其他关键帧观测到的地图点，将该地图点设置为NULL;



6、检测并插入关键帧，创建新的关键帧CreateNewKeyFrame：

将当前帧构造成关键帧，将当前关键帧设置为当前帧的参考关键帧，关键帧插入到mlNewKeyFrames，等待mpLocalMapper处理。

